[TOC]

#### 1.介绍


优点: 在内存中二进制流的拷贝，比直接new性能好得多

缺点: 直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。


#### 2.定义

>GOF定义:  用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

#### 3.使用场景

- 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗
- 通过new产生一个对象需要非常繁琐的数据准备或访问权限
- 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者调用，即保护性拷贝。

>通过实现Cloneable接口的原型模式在调用clone函数构造实例时并不一定比new操作快。只有通过new构造对象较为耗时或成本较高时，通过clone才能获得效率的提升。


#### 4.组成

- 1) 客户角色:让一个原型克隆自己来得到一个新对象。- 2) 抽象原型角色:实现了自己的 clone 方法，扮演这种角色的类通常是抽象类，且它具有许多具体的子类。- 3) 具体原型角色:被复制的对象，为抽象原型角色的具体子类。

![原型模式](https://github.com/sparkfengbo/AndroidNotes/blob/master/PictureRes/SJMS/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png?raw=true)

#### 5.例子

实现Cloneable接口

#### 6.深拷贝和浅拷贝

在实现Cloneable接口复写clone方法时，调用clone方法，如果是引用类型，就会实现浅拷贝，clone后得到的对象中引用类型的成员指向的其实是原对象的引用类型成员，如果想实现深拷贝，那么引用类型的成员同时也需要调用clone方法。

- [Java中的深拷贝(深复制)和浅拷贝(浅复制)](http://www.cnblogs.com/shuaiwhu/archive/2010/12/14/2065088.html)

#### 7.Android中的使用

intent

