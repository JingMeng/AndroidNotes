<!DOCTYPE html>
<!-- saved from url=(0045)http://chanpin.family.baidu.com/article/50122 -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>
        
Android性能优化的那些事-《观点》第六期
    </title>
    <!--<base href="http://chanpin.family.baidu.com">--><base href=".">
    <link rel="stylesheet" href="./Android性能优化的那些事-《观点》第六期_files/global.less.min.css">
    <link type="image/x-icon" rel="shortcut icon" href="http://static.family.baidu.com/portal/static/img/favicon.ico?v=3.6.5">
    
<script src="./Android性能优化的那些事-《观点》第六期_files/hm.js"></script><script src="./Android性能优化的那些事-《观点》第六期_files/html5media.min.js"></script>
    
<link rel="stylesheet" href="./Android性能优化的那些事-《观点》第六期_files/articleDetail.less.min.css">
<script src="./Android性能优化的那些事-《观点》第六期_files/bpit.js"></script><link rel="stylesheet" type="text/css" href="./Android性能优化的那些事-《观点》第六期_files/hishare.css"></head>
<body id="productForum" class="cp" style="position: static;">
<div id="skybg">
    
    <link rel="stylesheet" type="text/css" href="./Android性能优化的那些事-《观点》第六期_files/fsearch.css">
<link rel="stylesheet" href="./Android性能优化的那些事-《观点》第六期_files/familyframe.less.min.css">
<!-- HTMLshiv for IE -->
<!--[if lte IE 9]><script src="http://static.family.baidu.com/portal/lib/js/html5shiv.min.js"></script><![endif]-->
<!--[if (gte IE 6)&(lte IE 8)]>
  <script type="text/javascript" src="http://static.family.baidu.com/portal/lib/js/selectivizr.min.js"></script>
<![endif]-->
<style>
  .nav > form input[type='text']{
    height:auto;
  }
  footer{
    margin:20px auto 0;
  }
  .ui-helper-hidden-accessible{
    display:none;
  }
</style>
    <div class="wrapper">
        <div class="container" style="background: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAABQCAYAAABoMayFAAACcUlEQVR42u3dSW7bQBBAUd3/sobhA3hYeEOI7KomRXV1vwdkkdDIQgF+qjjp8QAAAAAAAAAAAAAAAACguI/Pr++/Xz4JYLnw/cdPBIFl4udTAAQQYJXIiR8wffwyAXQhBFgugNufE0KgVOT2JrrWGmxFBqab8AQQmD6AkWPRnxNAYMj1tjXFbY+3fi+AQKnp7lnUogE7Woe3T4KIHzD8ahud4FpTpKkPKBnA1lTnOV9gyMhFz9+1Vt4zfwbw1gkvcm7vaJKLnrdzfg94y5R3do013QHl4heZALMBE0Cg1JqbWYF7/24RBIaY8o5W2GfHMufxfPLAEPHrec62d4oTP6DMFNgbwJ6bmAHeFsGrJj2hAwQQoHoEWxdBIqs0wO1By0Sp9+KF8AFDT3Nnb08ROKD0OiuCwLIToJuUgaUCmD0/5549YIoAXvV8LkD5NVjkYMDJg3si6N8GXhw+393gPyVYftUCEECAWUMnfsAS8ct+EY5PDVgmgN4OApQOXOsdb9mJTwCBktOdAAJLBDB63NuBgdIrbuQrDo8ilrkaLIDAcBNe5mLFXgCPXrnkAggw9HobWW33YunFmcA0AWytsZ71BYYMXOb83dHamzmPJ4DAUNNd9BaVvUku+w1iIgjcPun1TGZ7U2LPt4cB3B6/V6ymAgiUWnWvjJfze8CQE150he29/07ogCHi17pd5epH0MQPKDMF9gSwNS0CDBXB7HHP4AICKIDAzBFs3dQcWaUBbo9aNEy9Fy+EDxh+ojt7dVbkgNIrrQgCy06AAgcsFcCeN60IIVA+gJmQiR4w9RosdMCyEbTeAtZhAAAAAACAXz8Z5vhsDaDlJAAAAABJRU5ErkJggg==&quot;);">

</div>

</div>
<div class="p-content clearfix">
    <div class="main clearfix" data="true">
        
        
<div id="article-title" data-id="50122">
    <div class="title">
        <h3>
            
            <i class="category">交流<b></b></i>
            
            <em>Android性能优化的那些事-《观点》第六期</em>
            
            
            
        </h3>
    </div>
    
</div>

  <div class="article-content">
   <p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">&nbsp; &nbsp; &nbsp;众所周知，一款优秀的应用除了功能吸引人，好的性能也必不可少，为了让用户体验更佳，需要重视应用的性能并且持续不断的做性能优化。不过性能优化的效果仅凭感觉很难衡量，一切应该看数据说话，比如流畅度优化，刷新频率每秒越接近60帧越理想，但只要每秒钟超过24帧人眼就无法辨别是否流畅了，所以仅凭感觉是无法区分优化前的30帧和优化后的40帧的区别的。为了说明做性能优化有足够的价值，就有必要通过一系列指标来说明优化前后的区别。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">&nbsp; &nbsp; &nbsp;性能指标的定义应该具有可衡量、可比较的特点，所以每项性能指标可以是数值，也可以是一份报告，重点关注的性能指标：</span></p><ul><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">流畅度：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">FPS，越接近60帧越好；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">启动时间：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">时间，越短越好；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存问题包括内存泄露、内存占用和内存抖动。内存泄露可以通过AS静态代码检测、MAT检测，内存泄露很难用数值定义，但可以通过将优化前后工具检测的结果对比得出结论，没有内存泄露最好。内存占用要看峰值，峰值越大越容易OOM。内存抖动，抖动越频繁说明导致GC的可能性越大，性能问题也会越明显；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">功耗：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">单位时间内的掉电量，越少越好；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">APK</span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">体积：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">APK体积，越小越好</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  从上面各项性能指标的定义可以看出，性能优化效果的评估主要是通过对比得出来的，性能如何只是相对的。只要针对同一个应用的同一项指标，优化后比优化前更优，就说明优化是有效果的。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  确定了性能指标，还需要确定每项指标需要哪些工具来进行测试，重点介绍谷歌官方提供的一系列应用性能优化工具以及值得推荐的第三方性能优化工具，这些工具主要集中在如下几个地方：</span></p><ul><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">开发者选项：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">GPU呈现模式分析、GPU过渡绘制、严格模式等；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">IDE</span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">中：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">Android Studio，比如静态代码检测工具、Memory Monitor、CPU Monitor、NetWork Monitor、GPU Monitor、Layout Inspector、Analyze APK等；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">SDK</span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">中：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">sdk\tools，比如DDMS、HierarchyViewer、TraceView等；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">第三方性能优化工具：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">MAT、Leakcanary等；</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  指标和工具都有了，咱们的工作就可以正式启动了，但为了能够高效率地解决问题，有必要先介绍一下性能优化原则和方法。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">优化原则：</span></strong></p><ul><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">足够多的测量：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">不要凭感觉去检测性能问题、评估性能优化的效果，应该保持足够多的测量，数据不会说谎。使用各种性能工具有助于快速定位问题，这比凭感觉要靠谱得多；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">使用低配置的设备：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">同样的程序，在低端配置的设备中，相同的问题会暴露得更为明显；高配的设备很多时候会让你忽略掉性能问题；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">权衡利弊：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">在能够保证产品稳定、按时交付的前提下去做优化，不能顾此失彼，为了性能优化导致产品迟迟不能交付；</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  性能优化和解bug一样，只要讲方法，实践起来就会变得很简单。对于大多数问题来讲，只要遵循了解问题→定位问题→分析问题→解决问题→验证问题的思路，基本上都可以解决：</span></p><ul><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">了解问题：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">对于性能问题来讲，这个步骤只适用于某些明显的性能问题，很多无法感知的性能问题需要通过工具以及APM监控平台进行定位；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">定位问题：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">通过工具检测、分析，定位在什么地方存在性能问题；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">分析问题：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">找到问题后，分析针对这个问题该如何解决，确定解决方案；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">解决问题：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">如果是自己无法解决的问题，可以借助搜索引擎，你遇到过的问题很多人都遇到过，并且极有可能已经被解决了；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">验证问题：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">保证每一次优化都有效，没有产生新问题，保证产品的稳定；</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  </span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">下面针对每一个性能指标的优化做详细的介绍：</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><br></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">1. </span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">流畅度：</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  流畅度是反应应用使用过程中是否流畅的一个核心指标，应用越流畅，用户用起来就越爽。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  哪些问题会导致流畅度的问题呢？通常有：</span></p><ul><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存抖动：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存抖动导致频繁GC，GC在2.3之后虽然不是在UI线程中进行，但它在工作时会导致所有线程进入暂停状态，会存在卡顿的问题；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">过渡绘制：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">界面的过渡绘制问题，过渡绘制越严重，应用刷新一帧的时间就越长，丢帧就越多；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">UI</span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">阻塞：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">在UI线程中做了耗时操作，比如IO操作、网络访问、复杂的算法等，导致UI更新不及时；</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存抖动：</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  内存抖动可以通过Android Studio中的Android Monitor工具查看，将你的开发样机和PC相连，在AS的Android Monitor窗口选择所连接的设备，选择当前运行程序的进程名称（应用主进程名称同其包名）。如下图所示，程序在运行的过程中，内存会随着横向时间轴的流逝不断地变化，我们通过观察纵轴内存大小的变化情况来判断是否存在内存抖动，如果纵轴呈锯齿状，说明存在严重的内存抖动。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;"><img class="fr-dib fr-fil" src="./Android性能优化的那些事-《观点》第六期_files/pzQ+YZs45GPGq7QBNL4P0A==.jpeg" style="width: 685px; height: 255.733px;"></span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  导致内存抖动的主要原因是因为瞬时创建了很多局部变量，申请局部变量需要内存，局部变量生命周期结束后虚拟机GC回收了内存，所以就存在内存抖动的情况。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  跟踪这个问题可以在程序运行的过程中点击上图Memory字样右侧靠近问号的Start Allocation Tracking按钮，它可以分析程序运行某段时间内的内存申请情况，通过跟踪这段时间内的堆栈情况，找到是哪里频繁在创建局部变量。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  解决内存抖动的问题很简单，尽量避免在for、while以及频繁调用的方法中声明局部变量，局部变量越多，内存抖动的问题越明显。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">过渡绘制：</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  从Android 4.1开始，Android在其开发者选项中提供了一系列检测应用性能的工具，比如过渡绘制、GPU呈现模式、ANR等问题的检测，关于Android开发者选项的介绍可以参考这一篇文章：</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://www.jianshu.com/p/07b551ee260b"><span style="color:#1155CC;background:white;">15个必知的Android开发者选项</span></a></span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  显示过渡绘制区域的步骤如下：“开发者选项”→点击“调试GPU 过渡绘制”→点击“显示过渡绘制区域”</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;">。<span style="background:white;">Android通过不同颜色来区分同一个区域绘制的次数，颜色越深，表示过渡绘制的次数越多，过渡绘制越严重。如下图所示，蓝色表示存在一次过渡绘制；深红色表示同一区域存在4次及以上的过渡绘制：</span></span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;"><span style="background:white;"><img class="fr-dib" src="./Android性能优化的那些事-《观点》第六期_files/TayMXpUYL7lfWnDLPwGtA==.jpeg" style="width: 300px;"></span></span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  应用无法完全做到没有过渡绘制，优化是尽量避免不必要的过渡绘制，通常情况下保证同一区域过渡绘制少于三次都是合理的，即只要是出现红色（淡红色和深红色）的地方，就是需要优化的地方：</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;"><img class="fr-dib" src="./Android性能优化的那些事-《观点》第六期_files/5KS0ypxJJSa0RjQ2tUgrdg==.jpeg" style="width: 397px; height: 334.803px;"></span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  过渡绘制不仅仅会影响程序的刷新频率，还会导致程序启动慢、黑白屏、耗内存等问题，因为过渡绘制主要是因为布局复杂导致，android在加载布局文件的时候，实际上是读取xml文件并解析，然后根据每个视图的关系去测量、绘制、显示每一个视图；复杂的布局会需要更长的解析、测量、绘制、显示时间，也需要更多的内存（这与是否设置了视图背景有关）。在实际开发过程中，有如下几种常见的过渡绘制优化方法：</span></p><ul><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">在布局中使用merge标签，解决相同布局嵌套导致的过渡绘制问题；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">在布局中使用ViewStub标签，可以解决动态加载页面布局，避免默认加载不必要布局的问题；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">在布局中使用Space标签，可以解决只占位、不刷新的视图问题；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">去掉Window背景，一个界面就是一个Window，Activity是依附在Window之上的，无论在AndroidManifest.xml中是否给当前界面设置了主题，Window都会存在一个默认的背景，这时如果给Activity也设置了背景，相当于在什么也没做的情况下同一个界面被绘制了两次，所以建议给Activity定义一个自定义主题，在自定义主题中通过android:windowBackground=”@null”去掉window的默认背景，通过这种方式可以解决大部分界面的过渡绘制问题，但要注意，因为Window的背景去掉了，所以必须要给每个Activity都设置背景，否则会出现界面为一块黑色的情况；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">最重要的是产品设计合理，多和产品、UI沟通，避免无意义的工作。</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  如果你想进一步验证过渡绘制到底有多耗时，可以通过android官方提供的HierarchyViewer工具，检测布局中的每一个组件在初始化过程中测量、绘制和显示所需要的时间。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">UI</span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">阻塞：</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  对UI阻塞的检测Android官方提供了好几个工具：StrictMode严格模式、开发者选项中的GPU呈现模式、性能检测工具TraceView。我通常是使用StrictMode和GPU呈现模式定位到UI阻塞的大致位置，然后再用TraceView确定具体的原因。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  StrictMode是Android从2.3开始提供的一个功能，它是</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;background:#F8F8F8;">用来检测程序中违例情况的开发者工具。最常用的场景就是检测主线程中本地磁盘和网络读写等耗时的操作。它既可以集成在代码中，又可以通过开发者选项中的开关打开。关于StrictMode的详细介绍可以参见这篇文章：</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/index.html"><span style="color:#1155CC;background:#F8F8F8;">Android性能调优利器StrictMode</span></a></span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  从Android 4.1开始，在“开发者选项”中提供了GPU呈现模式分析的选项，GPU呈现模式是一个方便你快速观察UI渲染效率的工具，主要作用是实时查看每一帧的渲染效率，定位哪里存在渲染的性能问题；通过如下方式可以打开GPU呈现模式分析：“系统设置”→“开发者选项”→“GPU呈现模式分析”→在弹出的窗口中选择“在屏幕上显示成条形图（On screen as bars）”。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  打开GPU呈现模式后，你可以在机器的任何界面看到如下图所示的条形图，顶部通知栏、当前活动程序（主窗口）、底部导航栏都会有对应的呈现模式条形图，用于观察通知栏、当前活动界面、导航栏的渲染效率。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  随着界面的刷新，界面上会滚动显示垂直的柱状图来表示每帧画面所需要的渲染时间，柱状图越高表示花费的渲染时间越长。中间有一根绿色的横线，代表每帧的最长渲染时间：16ms，我们需要确保每一帧花费的总时间都低于这条横线，这样才能够避免出现卡顿的问题。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;"><img class="fr-dib" src="./Android性能优化的那些事-《观点》第六期_files/KldcbZ9CwbWnWv4uNCD4UA==.jpeg" style="width: 300px;"></span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  每种颜色代表每一帧渲染过程中需要完成的某一件事情，从6.0开始，将每一帧的渲染过程拆分成了8个步骤，每个步骤一种颜色，每种颜色的意义如下：</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><img class="fr-dib" src="./Android性能优化的那些事-《观点》第六期_files/zT4uIdpf7WqhXn9JBs4fQQ==.jpeg" style="width: 300px;"></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  通过StrictMode和GPU呈现模式确定导致UI阻塞的大致位置后，就可以借助TraceView工具精确定位问题了，TraceView可以检测程序在运行的某一段时间内具体是哪里耗时，可以看一下这篇文章，讲解得非常详细：</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://bxbxbai.github.io/2014/10/25/use-trace-view/"><span style="font-size:16px;color:#1155CC;background:white;">正确使用Android性能分析工具——TraceView</span></a></span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><br></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">2. </span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">启动时间</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  这里说的是应用冷启动的时间，所谓冷启动就是应用没在后台运行且不是在安装后首次启动的情况下的启动，计算安装后首次启动和热启动（程序在后台运行的状态下启动）的时间意义不大，因为首次启动需要涉及到APK的解析，热启动耗时通常都不会超过1S，通过冷启动计算应用的启动时间是最合理的。通常有如下几种方式来测量应用的启动时间：</span></p><ul><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">掐秒表，这是最原始也是最不靠谱的方式；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">使用命令行adb shell am start -w packagename/MainActivity统计应用的启动时间，具体看这里：</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://androidperformance.com/2015/12/31/How-to-calculation-android-app-lunch-time.html"><span style="color:#1155CC;background:white;">Android 中如何计算 App 的启动时间？</span></a></span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">代码中打点，官方建议在onWindowFocusChanged回调里面打点，不过此时view还没开始绘制；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">使用高速相机和录屏软件，来记录应用的启动时间。使用高速相机记录应用的启动时间是最精确的。</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  导致应用冷启动慢的原因是在Application的onCreate方法或者主Activity启动时做了耗时的操作，所以将需要在Application中初始化的工作异步处理，优化主Activity的布局和初始化流程，从而减少应用冷启动的时间。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><br></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">3 </span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  内存导致的性能问题有三种可能，分别是：</span></p><ul><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">应用内存占用大</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">，导致程序容易OOM，特别是在低配置的设备上；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">应用存在内存泄露</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">，系统需要内存的时候程序不能立即释放不需要的内存；</span></li><li><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存抖动</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">，内存抖动会导致卡顿的问题。</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存占用优化：</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  </span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  内存占用的优化可以从几个方面出发：</span></p><ul><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">涉及到IO操作使用完后立即关闭；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">合理地定义缓存大小，缓存越大，占用的内存就越大；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">尽量避免创建大对象以及大量地对象，实例化一个对象本身就会占用内存；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">程序中用到的图片要放在合适的drawable文件夹下，这一点在官方文档中并没有讲到，同样的程序放在不同的设备上，占用的内存会不一样，这与图片在程序中放置的位置以及设备的屏幕密度有关，具体可以参考这篇文章：</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://blog.csdn.net/guolin_blog/article/details/50727753"><span style="color:#1155CC;background:white;">&nbsp;Android drawable微技巧，你所不知道的drawable的那些细节</span></a></span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">如果你的应用没有复杂的动画效果，可以考虑关掉硬件加速，硬件加速会额外地增加内存的占用。</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内存泄露优化：</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">   java这门语言中并不存在严格意义的内存泄露，这里所说的内存泄露是指内存在需要释放的时候没有及时释放。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  检测Android应用的内存泄露方法已经很成熟了，主要是借助开源项目Leakcanary、adb shell dumpsys meminfo命令行和MAT工具，命令行用于大致定位哪个地方可能存在内存泄露，然后用Leakcanary和MAT工具分析应用的内存快照，确定具体的内存泄露位置。通过上述三种方式查看内存泄露情况时，我有一个习惯，就是先手动触发GC，模拟虚拟机的GC操作，先释放没有用到的内存。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  进入应用后，把所有界面的所有功能都玩个遍，然后退出程序，手动触发GC（点击AS的Android Monitor中的Inital GC按钮）。然后使用命令“adb shell dumpsys meminfo your_packagename”查看程序处于后台时的Context、Activity和View的数量，如果AppContext的数量不是1说明存在内存泄露（除了四大组件的context外，还有ApplictionContext），View和Activity的数量不是0也表示存在内存泄露</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;">。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  确定应用的某个界面存在内存泄露后，就可以借助LeakCanary和MAT来定位具体的内存泄露位置了，具体的使用方法：</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/"><span style="font-size:16px;color:#1155CC;background:white;">LeakCanary 中文使用说明</span></a></span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">，在程序运行的过程中，这个工具会不断地通过程序触发GC操作，然后分析当前的内存快照，实时分析并定位内存泄露问题。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">MAT相比于LeakCanary，虽然不是侵入式的，但会稍微麻烦一些，照我的理解，MAT并不是一个内存泄露的检测工具，它只是一个内存快照的分析工具，它可以分析每个方法的堆栈和引用关系，并不会明确告诉你哪里存在内存泄露，这需要你人为地进行观察。关于MAT的具体使用方式，可以看下这篇文章：</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://blog.csdn.net/xiaanming/article/details/42396507"><span style="color:#1155CC;background:white;">Android 性能优化之使用MAT分析内存泄露问题</span></a></span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><br></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  </span><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">内</span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">存抖动：</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  尽量避免在循环和频繁调用的方法中做内存申请的操作即可，比如申请很多局部变量。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><br></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">4. </span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">功耗：</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  功耗导致的性能问题主要表现在两个方面：掉电快和发热。导致功耗问题的常见原因有如下几种：</span></p><ul><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">频繁地网络访问，网络请求需要先建立连接，建立连接的过程会很耗电；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">频繁地界面刷新，导致CPU和GPU高负荷工作；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">程序中使用了WakeLock后没有禁止掉，导致无法进入待机状态；</span></li></ul><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  综上，我们可以借助AS中Android Monitor的CPU和GPU Monitor观察程序运行过程中的界面刷新情况，可以通过Network Monotor观察程序运行过程中的网络请求情况，这样就可以知道程序中是否存在频繁的界面刷新以及网络访问操作。对于WakeLock的问题，可以在代码中搜索一下相关的类，检查使用完后是否有关闭。</span></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  知道导致功耗的原因，解决功耗问题也就很简单了，总结如下：</span></p><ul><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">优先使用缓存方案，尽量减少网络请求操作（也可以建立长连接，减少网络连接的次数）。其次是网络访问要集中，比如用户使用记录和埋点信息上传可以先缓存到本地，待程序在后台运行或者退出程序时统一上传；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">和视觉沟通，尽量减少循环动画的使用，如果要使用，可以改成触发后执行的这种方式，不要一进入应用就播循环动画；其次是减少界面的过渡绘制，刷新时尽量只刷新脏区域；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">WakeLock使用完后一定要记得关掉。</span></li></ul><p class="1CxSpMiddle" style="margin-top:8.0pt;margin-right:0cm;margin-bottom:11.0pt;margin-left:18.0pt;"><br></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">5. APK</span></strong><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">大小：</span></strong></p><p class="1" style="margin:0cm;margin-bottom:11.0pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:8.0pt;margin-right:0cm;margin-left:0cm;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">  从Android Studio 2.2开始，它提供了Analyze APK（Android Studio→Build→Analyze APK）的功能，它可以分析任何一个应用的各种资源占用空间的情况，总结一下APK瘦身的主流姿势：</span></p><ul><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">APK中图片是大头，所以尽量使用一套图片资源，</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">建议取720p的资源，放到xhdpi目录；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">通过Android Studio的Inspect Code检测代码中的Unused Resources，删掉这些无用的资源；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">使用</span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://www.tinypng.com%E5%AF%B9png%E5%92%8Cjpg%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A4%A7%E5%B9%85%E5%87%8F%E5%B0%8F%E5%9B%BE%E7%89%87%E7%9A%84%E7%89%A9%E7%90%86%E5%A4%A7%E5%B0%8F%EF%BC%9B/"><span style="color:#1155CC;background:white;">www.tinypng.com</span></a></span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">对png和jpg图片进行压缩，可以大幅减小图片的物理大小；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">对于背景大图或者不需要alpha透明度的图片，可以使用jpg格式代替png的图片，虽然在移动设备中jpg的渲染效率比不上png，但对于目前的主流手机来讲，基本上没啥差别了；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">对于占用物理空间大的图片，可以考虑使用webP图片格式；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">对于so，目前的主流架构是arm，所以可以考虑删掉x86和mips文件夹下的so；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">使用微信开源的资源压缩打包工具，具体可以参见：</span><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd"><span style="font-size:16px;color:#1155CC;background:white;">安装包立减1M--微信Android资源混淆打包工具</span></a></span><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">能用程序实现的就不用图片，能用9图的就不用普通的图片，可以节省不少空间，在Android 6.0及以上的版本中，对于按钮的正反选可以只提供一张正选的图片，使用tintcolor着色；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">程序和数据分离，对于需要依赖数据的应用，可以考虑像游戏那种方式，APK中不包含需要的数据，APK正式运行或者到需要使用数据的界面时才下载数据，如果必须要将数据预置到APK中，强烈建议使用7z将文件压缩后放进去，在程序运行时使用7z解压库解压这个数据；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">音频资源千万不要用无损的，比如wav，无损的音频会非常大，建议使用mp3；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">对代码做混淆，也可以减小APK的体积；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#555555;background:white;">如果你的应用足够复杂，比如像手百这样的平台级或者超级应用，可以考虑使用插件化机制。</span></li></ul><p class="1" style="margin:0cm;margin-bottom:.0001pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:11.0pt;"><br></p><p class="1" style="margin:0cm;margin-bottom:.0001pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:11.0pt;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">&nbsp;  对于应用的性能优化，提供一些建议：</span></p><ul><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">很多性能问题都是可感知的，但优化过程中一定要看数据说话；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">改善完成后一定要验证，避免因为改善性能问题导致程序不稳定；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">如果优化过程中需要大改程序，建议以稳定为主，先保证可用，再才是好用；</span></li><li><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">性能优化是一个持续地过程，应该将性能优化作为日常，将性能优化放在版本迭代中去，这样问题既能得到改善，也不会额外占用开发人员的时间。</span></li></ul><p class="1" style="margin:0cm;margin-bottom:.0001pt;font-size:15px;font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black;margin-top:11.0pt;"><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;"> </span><strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">参考资料</span></strong><span style="font-size:16px;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333;background:white;">：</span></p><ul><li><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" rel="noopener noreferrer" target="_blank"><span style="font-size:16px;color:#4094C7;background:white;">Android Performance Patterns</span></a></span></li><li><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="http://hukai.me/blog/archives/" rel="noopener noreferrer" target="_blank"><span style="font-size:16px;color:#4094C7;background:white;">Android性能优化典范</span></a></span></li><li><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="https://github.com/Juude/awesome-android-performance" rel="noopener noreferrer" target="_blank"><span style="font-size: 18px;">awesome-android-performance</span></a></span></li><li><span style="font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;"><a href="https://developer.android.com/topic/performance/reduce-apk-size.html#apk-structure" rel="noopener noreferrer" target="_blank"><span style="font-size:16px;color:#1155CC;background:white;">Reduce APK Size</span></a></span></li></ul>

        </div>
  



    </div>
    
    
</div>
<span class="toTop" id="toTop" style="display: inline;"></span>


<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?e5c8f30b30415b1fc94d820ba9d4d08c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://img.baidu.com/hunter/bpit.js?st='+~(new Date()/864e5)];
</script>
<script src="./Android性能优化的那些事-《观点》第六期_files/jquery.min.js"></script>
<script src="./Android性能优化的那些事-《观点》第六期_files/fsearch.js"></script>
<script src="./Android性能优化的那些事-《观点》第六期_files/plugins.min.js"></script>

<script src="./Android性能优化的那些事-《观点》第六期_files/jquery.ui.widget.js"></script>
<script src="./Android性能优化的那些事-《观点》第六期_files/jquery.fileupload.js"></script>
<script src="./Android性能优化的那些事-《观点》第六期_files/jquery.iframe-transport.js"></script>
<script src="./Android性能优化的那些事-《观点》第六期_files/share-sdk.min.js"></script>
<script src="./Android性能优化的那些事-《观点》第六期_files/article.min.js"></script>
<audio controls="controls" style="display: none;"></audio></body><style type="text/css">#yddContainer{display:block;font-family:Microsoft YaHei;position:relative;width:100%;height:100%;top:-4px;left:-4px;font-size:12px;border:1px solid}#yddTop{display:block;height:22px}#yddTopBorderlr{display:block;position:static;height:17px;padding:2px 28px;line-height:17px;font-size:12px;color:#5079bb;font-weight:bold;border-style:none solid;border-width:1px}#yddTopBorderlr .ydd-sp{position:absolute;top:2px;height:0;overflow:hidden}.ydd-icon{left:5px;width:17px;padding:0px 0px 0px 0px;padding-top:17px;background-position:-16px -44px}.ydd-close{right:5px;width:16px;padding-top:16px;background-position:left -44px}#yddKeyTitle{float:left;text-decoration:none}#yddMiddle{display:block;margin-bottom:10px}.ydd-tabs{display:block;margin:5px 0;padding:0 5px;height:18px;border-bottom:1px solid}.ydd-tab{display:block;float:left;height:18px;margin:0 5px -1px 0;padding:0 4px;line-height:18px;border:1px solid;border-bottom:none}.ydd-trans-container{display:block;line-height:160%}.ydd-trans-container a{text-decoration:none;}#yddBottom{position:absolute;bottom:0;left:0;width:100%;height:22px;line-height:22px;overflow:hidden;background-position:left -22px}.ydd-padding010{padding:0 10px}#yddWrapper{color:#252525;z-index:10001;background:url(chrome-extension://eopjamdnofihpioajgfdikhhbobonhbb/ab20.png);}#yddContainer{background:#fff;border-color:#4b7598}#yddTopBorderlr{border-color:#f0f8fc}#yddWrapper .ydd-sp{background-image:url(chrome-extension://eopjamdnofihpioajgfdikhhbobonhbb/ydd-sprite.png)}#yddWrapper a,#yddWrapper a:hover,#yddWrapper a:visited{color:#50799b}#yddWrapper .ydd-tabs{color:#959595}.ydd-tabs,.ydd-tab{background:#fff;border-color:#d5e7f3}#yddBottom{color:#363636}#yddWrapper{min-width:250px;max-width:400px;}</style></html>