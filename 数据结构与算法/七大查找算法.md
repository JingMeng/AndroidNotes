# 七大查找算法

**参考文章**

- [[Data Structure & Algorithm] 七大查找算法](http://www.cnblogs.com/maybe2030/p/4715035.html#_label1)
- [斐波那契查找（黄金分割法查找）(仅使用加减实现的二分查找)](https://blog.csdn.net/zsw12013/article/details/50003505)

>查找算法分类：
>
> - 1）静态查找和动态查找；
> 
>　　　　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。
>
> - 2）无序查找和有序查找。
> 
>　　　　无序查找：被查找数列有序无序均可；
>
>　　　　有序查找：被查找数列必须为有序数列。
>
>
>　　平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。
>
>　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。
>
>　　Pi：查找表中第i个数据元素的概率。
>
>　　Ci：找到第i个数据元素时已经比较过的次数。

## 1. 顺序查找

顺序查找适合于存储结构为顺序存储或链接存储的线性表。

**基本思想：**顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

**时间复杂度为O(n)**


## 2. 二分查找

**说明：元素必须是有序的，如果是无序的则要先进行排序操作。**

**基本思想：**二分查找也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

**时间复杂度为O(log2n)**

## 3. 插值查找

**基本思想：**基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。

**时间复杂度为O(log2(log2n))** [Interpolation Search A LogLogN Search](http://www.cs.technion.ac.il/~itai/publications/Algorithms/p550-perl.pdf)

>折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。
>
>二分查找中查找点计算如下：
>    `mid=(low+high)/2, 即mid=low+1/2*(high-low);`
>
>通过类比，我们可以将查找的点改进为如下：
>    `mid=low+(key-a[low])/(a[high]-a[low])*(high-low)`
>
>也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。

```
//插值查找
int InsertionSearch(int a[], int value, int low, int high)
{
    int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);
    if(a[mid]==value)
        return mid;
    if(a[mid]>value)
        return InsertionSearch(a, value, low, mid-1);
    if(a[mid]<value)
        return InsertionSearch(a, value, mid+1, high);
}
```

## 4. 斐波那契查找

斐波那契查找相对二分查找有啥优势呢？仅使用加法减法，不需要使用除法。（个人觉得吧，这个算法实用性并不强，顶多面试题出一出）

对于斐波那契数列：1、1、2、3、5、8、13、21、34、55、89……（也可以从0开始），前后两个数字的比值随着数列的增加，越来越接近黄金比值0.618。比如这里的89，把它想象成整个有序表的元素个数，而89是由前面的两个斐波那契数34和55相加之后的和，也就是说把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段，那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，假如要查找的元素在前半段，那么继续按照斐波那契数列来看，55 = 34 + 21，所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，继续查找，如此反复，直到查找成功或失败，这样就把斐波那契数列应用到查找算法中了。

![](https://github.com/sparkfengbo/AndroidNotes/blob/master/PictureRes/SJJG/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%8E%92%E5%BA%8F.jpeg?raw=true)

斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数n为某个斐波那契数小1，即n=F(k)-1;

开始将key值与第F(k-1）位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种

- 1）相等，mid位置的元素即为所求

- 2）key > array[mid], low=mid+1,k-=2;说明:low=mid+1说明待查找的元素在[mid+1,hign]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-（F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找

- 3) key < array[mid], high=mid-1,k-=1;说明:low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归的应用斐波那契查找


**时间复杂度为O(log2n)**


```
// 斐波那契查找.cpp 

#include "stdafx.h"
#include <memory>
#include  <iostream>
using namespace std;

const int max_size=20;//斐波那契数组的长度

/*构造一个斐波那契数组*/ 
void Fibonacci(int * F)
{
    F[0]=0;
    F[1]=1;
    for(int i=2;i<max_size;++i)
        F[i]=F[i-1]+F[i-2];
}

/*定义斐波那契查找法*/  
int FibonacciSearch(int *a, int n, int key)  //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字
{
  int low=0;
  int high=n-1;
  
  int F[max_size];
  Fibonacci(F);//构造一个斐波那契数组F 

  int k=0;
  while(n>F[k]-1)//计算n位于斐波那契数列的位置
      ++k;

  int  * temp;//将数组a扩展到F[k]-1的长度
  temp=new int [F[k]-1];
  memcpy(temp,a,n*sizeof(int));

  for(int i=n;i<F[k]-1;++i)
     temp[i]=a[n-1];
  
  while(low<=high)
  {
    int mid=low+F[k-1]-1;
    if(key<temp[mid])
    {
      high=mid-1;
      k-=1;
    }
    else if(key>temp[mid])
    {
     low=mid+1;
     k-=2;
    }
    else
    {
       if(mid<n)
           return mid; //若相等则说明mid即为查找到的位置
       else
           return n-1; //若mid>=n则说明是扩展的数值,返回n-1
    }
  }  
  delete [] temp;
  return -1;
}

int main()
{
    int a[] = {0,16,24,35,47,59,62,73,88,99};
    int key=100;
    int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);
    cout<<key<<" is located at:"<<index;
    return 0;
}
```
## 5. 树表查找

### 5.1 二叉查找树

**基本思想：**二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 

**二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。**

**时间复杂度为O(log2n)**但是如果二叉查找树不平衡的话，效率会很低


### 5.2 2-3查找树

### 5.3 红黑树

- [关于红黑树](https://github.com/sparkfengbo/AndroidNotes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91.md)

### 5.4 B树和B+树

B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。

- [关于B树和B+树](https://github.com/sparkfengbo/AndroidNotes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B-%E6%95%B0%E4%B8%8EB%2B%E6%A0%91.md)

## 6. 分块查找

分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

算法思想：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……

算法流程：

step1 先选取各块中的最大关键字构成一个索引表；

step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。

**时间复杂度：O(log(m)+N/m)**（索引表分为m块，每块含有N/m个元素，块内是无序的，块间是有序的，对于log(m)取决于如何对索引表进行查找）

## 7. 哈希查找

**算法思想：**哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

算法流程：

- 1）用给定的哈希函数构造哈希表；
- 2）根据选择的冲突处理方法解决地址冲突；
	
	常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：[浅谈算法和数据结构: 十一 哈希表](http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html)
- 3）在哈希表的基础上执行哈希查找。

哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。

**复杂度分析：**

　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。

----------

|算法| 查找(最坏)|插入(最坏)|删除(最坏)|查找(最好)| 插入(最好)|删除(最好)|是否要求有序|
| --------  | :----: | :----: |:----: |:----: |:----: |:----: |:----: |
| 顺序结构  | N    |   N  |   N  |   N/2   |   N  |   N/2   |   No   |
| 二分算法  | logN |   N  |   N  |  logN |   N/2  |   N/2   |   Yes  |
| 二叉查找树(BST)  | N |  N  | N |1.39logN|1.39logN|   √‾N  |   Yes |
| 2-3树  | clogN | clogN | clogN | clogN | clogN | clogN | Yes  |
| 红黑树 | 2logN | 2logN | 2logN |  logN  | logN  | logN  |  Yes|
| 哈希散列查找 | logN | logN | logN  | 3~5  |  3~5 | 3~5  | No   |
| 哈希探针查找 | logN | logN | logN  | 3~5  |  3~5 | 3~5  | No   |
