### 1.原子性、可见性、有序性

#### 1.1 原子性

指一个操作是不可中断的，即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

例如 `int a = 10`这是一个原子操作，但是`a++; a = a + 1`就不是原子操作。

能够保证原子性的有：Java内存模型的8种操作、synchronized


#### 1.2 可见性

可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。

能够保证可见性的有：volatile、synchronized、final

#### 1.3 有序性

即程序执行的顺序按照代码的先后顺序执行。

能够保证有序性的有：volatile、synchronized、


-----

### 2.volatile


保证可见性、有序性，但**不保证原子性**

如果volatile保证原子性，必须满足下面两个条件

- 运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；
- 变量不需要与其他的状态变量共同参与不变约束




### 3.synchronized

### 4.transient

### 5.相关同步类

#### 5.1 AtomicInteger等

能够保证原子性，内部使用了volatile关键字

参考 

- [ JAVA 中无锁的线程安全整数 AtomicInteger介绍和使用](http://blog.csdn.net/bigtree_3721/article/details/51296064)

```
public class AtomicOperationDemo {  
       static AtomicInteger count=new AtomicInteger(0);  
       public static class AddThread implements Runnable{  
        @Override  
        public void run() {  
            for(int k=0;k<1000;k++){  
                count.incrementAndGet();  
            }  
         }   
       }  
       public static void AtomicIntShow(){  
         System.out.println("AtomicIntShow() enter");  
         ExecutorService threadpool =   Executors.newFixedThreadPool(10);  
           
         for(int k=0;k<100;k++){  
             threadpool.submit(new AddThread());  
         }  
           
         try {  
            Thread.sleep(2000);  
        } catch (InterruptedException e) {  
            // TODO Auto-generated catch block  
            e.printStackTrace();  
        }  
           
         /* output 
          * AtomicIntShow() enter 
          * result of acumulated sum=100000 
          * AtomicIntShow() exit 
          */  
           
         System.out.println("result of acumulated sum="+count);  
         threadpool.shutdown();  
         System.out.println("AtomicIntShow() exit");  
         return ;  
          
    }  
} 
```