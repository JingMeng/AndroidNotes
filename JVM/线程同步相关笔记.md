### 1.原子性、可见性、有序性

#### 1.1 原子性

指一个操作是不可中断的，即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

例如 `int a = 10`这是一个原子操作，但是`a++; a = a + 1`就不是原子操作。

能够保证原子性的有：Java内存模型的8种操作、synchronized


#### 1.2 可见性

可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。

能够保证可见性的有：volatile、synchronized、final

#### 1.3 有序性

即程序执行的顺序按照代码的先后顺序执行。

能够保证有序性的有：volatile、synchronized、


-----

### 2.volatile


保证可见性、有序性，但**不保证原子性**

如果volatile保证原子性，必须满足下面两个条件

- 运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；
- 变量不需要与其他的状态变量共同参与不变约束

>volatile关键字禁止指令重排序有两层意思：

>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
>

```
//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
```

由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。

并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。

**实现原理**

>4.volatile的原理和实现机制

>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。

>下面这段话摘自《深入理解Java虚拟机》：

>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”

>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

>2）它会强制将对缓存的修改操作立即写入主存；

>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。

可参考 

- [Java并发编程：volatile关键字解析](http://www.importnew.com/18126.html#comment-641837)


### 3.synchronized






### 4.transient

### 5.相关同步类

#### 5.1 AtomicInteger等

能够保证原子性，内部使用了volatile关键字

参考 

- [ JAVA 中无锁的线程安全整数 AtomicInteger介绍和使用](http://blog.csdn.net/bigtree_3721/article/details/51296064)

```
public class AtomicOperationDemo {  
       static AtomicInteger count=new AtomicInteger(0);  
       public static class AddThread implements Runnable{  
        @Override  
        public void run() {  
            for(int k=0;k<1000;k++){  
                count.incrementAndGet();  
            }  
         }   
       }  
       public static void AtomicIntShow(){  
         System.out.println("AtomicIntShow() enter");  
         ExecutorService threadpool =   Executors.newFixedThreadPool(10);  
           
         for(int k=0;k<100;k++){  
             threadpool.submit(new AddThread());  
         }  
           
         try {  
            Thread.sleep(2000);  
        } catch (InterruptedException e) {  
            // TODO Auto-generated catch block  
            e.printStackTrace();  
        }  
           
         /* output 
          * AtomicIntShow() enter 
          * result of acumulated sum=100000 
          * AtomicIntShow() exit 
          */  
           
         System.out.println("result of acumulated sum="+count);  
         threadpool.shutdown();  
         System.out.println("AtomicIntShow() exit");  
         return ;  
          
    }  
} 
```