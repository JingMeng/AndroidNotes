[TOC]


参考

周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） (原创精品系列) (Kindle 位置 1081-1083). 机械工业出版社. Kindle 版本. 

----

### 1.对象的创建

>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的**类加载过程**。>在类加载检查通过后，接下来虚拟机将为新生对象**分配内存**。对象所需内存的大小在类加载完成后便可完全确定

为对象分配空间的任务有两种方式

- 指针碰撞

	 Java堆中的内存是连续规整的，中间放着一个指针作为分界点的指示器
- 空闲列表

	Java堆中内存是不规整的，虚拟机需要维护一个列表记录哪些内存块是可用的
	
>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。
>
>
>接着，虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。
>
>之后执行`<init>`方法

### 2.对象的内存布局

对象在内存存储的布局分为三块

- 1.对象头
- 2.实例数据
- 3.对齐填充

**1.对象头**

分两部分

- 1.第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等- 2.对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。）


**2.实例数据**
>接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。**3.对齐填充**不是必然存在的，对象的大小必须是8字节的整数倍

### 3.对象的访问定位通过栈中的reference数据来操作堆上的具体对象，由于 reference 类型 在 Java 虚拟 机 规范 中 只 规定了 一个 指向 对象 的 引用， 并没有 定义 这个 引用 应该 通过 何种 方式 去 定位、 访问 堆 中的 对象 的 具体 位置， 所以 对象 访问 方式 也是 取决于 虚拟 机 实现 而定 的。 目前 主流 的 访问 方式 有 使用 句柄 和 直接 指针 两种。

>如果 使用 句柄 访问 的 话， 那么 Java 堆 中将 会 划分 出 一块 内存 来作 为 句柄 池， reference 中 存储 的 就是 对象 的 句柄 地址， 而 句柄 中 包含 了 对象 实例 数据 与 类型 数据 各自 的 具体 地址 信息，

![]()