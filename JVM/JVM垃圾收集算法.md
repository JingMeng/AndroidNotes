[TOC]


**参考**

周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） (原创精品系列) (Kindle位置1405). 机械工业出版社. Kindle 版本. 

----


>需要关注的问题：
>
 - 哪些内存需要回收
 - 什么时候回收
 - 如何回收

### 1.关注的区域：堆和方法区

>其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，### 2.判断对象是否存活

#### 2.1 引用计数法

实现简单、判定效率高。但无法解决 相互循环引用的问题

#### 2.2 可达性分析算法

通过`GC Roots`的对象作为起始点，从这些节点向下搜索，搜索所走过的路径成为引用链，如果对象到GC Roots不可达，说明此对象不可用。

**可作为GC Roots的对象包括**

- 虚拟机栈（栈帧中的本地变量表） 中的引用对象
- 方法区中的类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

(全局性引用，例如常量或类的静态属性、与执行上下文，例如栈帧中的本地变量表)

>关于finalize方法，参考 3.2.4
>finalize方法只会被调用一次，并且应该避免使用

### 3.方法区的回收


永久代的垃圾收集主要回收两部分：1.废弃常量  2无用的类

满足下面三个条件才能称为无用的类：

- 1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
- 2.加载该类的ClassLoader已经被回收
- 3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

>是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。


### 4.垃圾回收算法

- 标记-清除算法
- 复制算法
- 标记-整理算法
- 分代收集算法


#### 4.1 标记-清除算法（Mark-Sweep）

分为两个阶段：标记和清除

标记:GC Roots 不可达

**不足**

- 效率问题，需要两个过程，并且标记和清除效率都不高
- 控件问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。#### 4.2 复制算法（Copying）

>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。而且当对象存活率较高时会进行较多的复制操作#### 4.3 标记-整理算法（Mark-Compact）

标记

整理：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

#### 4.4 分代收集算法（Generational Collection）

>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。### 5.HotSpot的算法实现

#### 5.1 枚举根节点

可达性分析对执行时间敏感

- 1.很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。- 2.GC停顿

**为什么GC时需要停顿所有的Java线程**

>因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。>由于目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。#### 5.2 安全点

>即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。>Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的.>对于Safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。
>
>这里有两种方案可供选择：抢先式中断（PreemptiveSuspension）和主动式中断（VoluntarySuspension）
>
>其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。
>
>而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，#### 5.3 安全区域

>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。
>
#### 5.4 垃圾收集器

![]()

图3-5展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。

- Serial收集器
  
   工作时停止其他工作线程，新生代收集器，简单高效，Client模式下的首选的新生代收集器
   
- ParNew收集器

   Serial的多线程版本，使用多条线程进行垃圾收集，Server模式下的首选的新生代收集器