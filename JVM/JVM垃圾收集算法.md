
**参考**

周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） (原创精品系列) (Kindle位置1405). 机械工业出版社. Kindle 版本. 

----


**需要关注的问题：**

 - 哪些内存需要回收
 - 什么时候回收
 - 如何回收

## 1. 关注的区域：堆和方法区

其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

而**Java堆和方法区**则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，


## 2. 判断对象是否存活

### 2.1 引用计数法

实现简单、判定效率高。但无法解决 相互循环引用的问题

### 2.2 可达性分析算法

通过`GC Roots`的对象作为起始点，从这些节点向下搜索，搜索所走过的路径成为引用链，如果对象到GC Roots不可达，说明此对象不可用。

**可作为GC Roots的对象包括**

- 虚拟机栈（栈帧中的本地变量表） 中的引用对象
- 方法区中的类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

(全局性引用，例如常量或类的静态属性、与执行上下文，例如栈帧中的本地变量表)

>关于finalize方法，参考 3.2.4,一个对象的finalize()方法只会被调用一次，并且应该避免使用

## 3. 方法区的回收

永久代的垃圾收集主要回收两部分：1.废弃常量  2无用的类

满足下面三个条件才能称为无用的类：

- 1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
- 2.加载该类的ClassLoader已经被回收
- 3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

>是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。


## 4. 垃圾回收算法

- 标记-清除算法
- 复制算法
- 标记-整理算法
- 分代收集算法


### 4.1 标记-清除算法（Mark-Sweep）

分为两个阶段：标记和清除

标记:GC Roots 不可达

**不足**

- 效率问题，需要两个过程，并且标记和清除效率都不高
- 控件问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 4.2 复制算法（Copying）

>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。而且当对象存活率较高时会进行较多的复制操作

### 4.3 标记-整理算法（Mark-Compact）

标记

整理：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

### 4.4 分代收集算法（Generational Collection）

>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。
>

![](http://dl.iteye.com/upload/picture/pic/49645/0456e532-ad5e-3634-9257-27305f6af4c1.png)



- [JVM调优总结（4）：分代垃圾回收](http://www.importnew.com/19255.html)


## 5. HotSpot的算法实现

### 5.1 枚举根节点

可达性分析对执行时间敏感

- 1.很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。
- 2.GC停顿

**为什么GC时需要停顿所有的Java线程**

>因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。


>由于目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当
是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。

### 5.2 安全点

>即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

>Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的.

>对于Safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。
>
>这里有两种方案可供选择：抢先式中断（PreemptiveSuspension）和主动式中断（VoluntarySuspension）
>
>其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。
>
>而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，

### 5.3 安全区域

>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。


### 5.4 垃圾收集器

![](https://github.com/sparkfengbo/AndroidNotes/blob/master/PictureRes/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png?raw=true)



图3-5展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。

具体参考 3.5

- Serial收集器
  
   工作时停止其他工作线程（Stop the world），新生代收集器，简单高效，Client模式下的首选的新生代收集器
   
- ParNew收集器

   Serial的多线程版本，使用多条线程进行垃圾收集，Server模式下的首选的新生代收集器，其他和Serial基本一致，也是（Stop the world）
   
- Parallel Scavenge收集器

	和ParNew相似，但Parallel Scavenge不像ParNew等尽可能缩短垃圾收集时用户线程的停顿时间，而是达到可控制的吞吐量。吞吐量= 运行用户代码时间 /（ 运行用户代码 时间 + 垃圾收集时间）
	
	
	
	----
	
- Serial Old收集器

 单线程收集器，标记-整理算法
 
- Parallel Old收集器
 
 多线程，标记-整理算法
 
- CMS（Concurrent Mark Sweep）收集器

   标记-清除算法

   优点： 并发收集、 低停顿
   
   缺点：
   	- CMS收集器对 CPU 资源 非常敏感;
   	- CMS收集器无法处理浮动垃圾;
   	- 使用标记-清除算法，会产生碎片，给大对象分配带来困难


   
>CMS收集器无法处理浮动垃圾（FloatingGarbage），可能出现"ConcurrentModeFailure"失败而导致另一次FullGC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。
>
>CMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

>整个过程分为4个步骤，包括：初始标记（CMSinitialmark）并发标记（CMSconcurrentmark）重新标记（CMSremark）并发清除（CMSconcurrentsweep）

>其中，初始标记、重新标记这两个步骤仍然需要"StopTheWorld"。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集
器的内存回收过程是与用户线程一起并发执行的。


- G1（Garbage-First）收集器

>与其他GC收集器相比，G1具备如下特点。
>
> - 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
> 
> - 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
> 
> - 空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
> 
> - 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。
> 
> 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。
> 
> **具体参考 3.5.7**


## 6. 内存分配和回收策略

### 6.1 对象优先在Eden区分配

> - 新生代GC（MinorGC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。
> - 老年代GC（MajorGC/FullGC）：指发生在老年代的GC，出现了MajorGC，经常会伴随至少一次的MinorGC（但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）。MajorGC的速度一般会比MinorGC慢10倍以上。

--

>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。

### 6.2 大对象直接进去老年代

>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。

### 6.3 长期存活的对象将进入老年代
>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。



### 6.4 动态对象年龄的判定

>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。


### 6.5 空间分配担保
>
>在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么MinorGC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次FullGC。









